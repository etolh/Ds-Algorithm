### Programming Assignment 4: 8 puzzle
一个包含n*n个格子的样板，其中包含n*n-1个格子有数字1~n*n-1，1个为空格，用0表示；
目标状态是数字有序，使用A*算法求出从起始Board到目标Board的步骤数和每步状态。

 0  1  3        1  0  3        1  2  3        1  2  3        1  2  3
 4  2  5   =>   4  2  5   =>   4  0  5   =>   4  5  0   =>   4  5  6
 7  8  6        7  8  6        7  8  6        7  8  6        7  8  0

 initial                                                      goal

#### A*算法
#####简介
此问题中我们将每一个Board状态、从起始Board达到该Board所需步数moves、当前Board的前一个状态设成一个结点node：
1. 初始时结点node为（initial，0，null），将初始结点插入优先队列；
2. 每次从优先队列中取出优先级最大的结点，遍历取出结点的所有邻接结点，计算其moves并设置pre，插入到优先队列。
3. 当从优先队列中取出的结点为目标结点时，即停止，否则不断重复2
4. 当取到目标结点后，即可利用pre属性不断向前遍历找到最短路径。

#### 说明
1. A*算法是一种启发式搜索，其核心是每次选择优先级最大的结点再进行遍历，8puzzle优先级取决于该结点到达目标结点所需的消费，用f=g+h表示，其中g是从起始结点到此结点的消费用moves表示，h是从此结点到目标结点的预计消费，有两种方式进行估计：Hamming和Manhattan，Hamming是Board中位置错误的格子数，Manhattan是Board每个格子要到达目标位置的最少移动数之和。（不计算空白格子）

2. 当前结点的所有邻接结点中包含当前结点的前一个结点，添加时需要去掉重复

3. 缓存Manhattan，优先级使用Manhattan进行比较，若使用的比较器直接调用Manhattan方法，则每次比较结点时都需要调用Manhattan；因此在结点中使用一个变量在构建结点时缓存Manhattan距离，即每新建一个结点其Manhattan已经包含在结点中了，当要进行比较时，直接调用对象中的Manhattan距离即可无需调用方法。

4. 不是所有的起始Board最终都能到达目标状态，若将无法达到目标状态的Board中任意两个格子互换，则互换后的Board能达到目标状态


#### Board
1. 定义Board数据类型，完成对Board的各种操作，如求Hamming、Manhattan和其所有邻接结点等。

#### Solver
1. 根据传入的initial board得到最短查找路径，设置一个结点类型Node包含Board、moves、pre和priority，其中priority用于缓存Manhattan距离，在构造中设置。设置比较器用于比较priotity=Manhattan+moves，将初始结点加入优先队列后；不断从队列中取出最小优先的结点，并遍历其邻接结点加入队列（去重复），直到取出目标结点为止。

2. 每次取出的最小优先结点不一定是前面取出结点的邻接（子）结点，可能前面结点的子节点的优先级增大，因此无法根据取出结点得到路径连接，而是应该在得到目标结点后根据前pre链接向前遍历，反向寻找到起始结点从而得到路径。

3. 为了区分unsolvered结点，可以构建一个起始结点的twin结点，将两个结点进行同步操作（两个优先队列），某一时刻肯定存在一个结点达到目标状态。

####优化注意
1. 使用一维数组char[]来代替二维数组节约空间
2. 计算邻接结点的Manhattan等不必重新全部计算。
3. 结点去重复时注意使用equals，而非==。
4. 注意构造结点时缓存Manhattan，比较器中直接取值，不再调用。
