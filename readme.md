###Percolation
1. 问题：一个有n*n个格子的系统，格子有开闭两种状态（open、block），当一个格子与最上层的格子是相通的，则认为这个格子是满的（full），我们认为如果在最底层存在一个满的格子则该系统是渗透的（percolate），换句话说，即如存在从最上层到最底层的通路，系统渗透。假如一个格子打开的概率是p，存在一种现象，存在一个p*，当p``<``p*时，该系统几乎不渗透；当p``>``p*时，系统几乎总是渗透，分析域值p*

2. 分析：
    1. Percolation：设定一个n*n格子的系统，计算当系统渗透时，格子打开的数目得到p*。
    2. PercolationStats：对Percolation中实验进行若干次独立重复实验，得到p*的期望和方差。

3. 解决思路：
    1. Percolation设置一个fopen[n][n]二维数组，表示每个格子的开合情况。
    2. 调用Union-Find模型：若上层和下层存在格子在一个集合中（connect）则表示渗透，主要问题：
        1. 将二维的格子映射为一维的整数：以0开始，(row-1)*n+col-1
        2. 若分别对上层、下层格子一一遍历，查找其是否connect，复杂：
            + 新增2个格子（整数）分别于上层、下层所有格子相连，判断是否存在伤心层格子互连，只需判断新增的两个格子是否互连。
            + 由于直接调用UF模型，无法将新增的格子包在调用的UF对象中来，因此将新增的上层格子设为第一个格子up=0,下层格子设为down=n^2-1
            + backwash问题：参见V2
    3. Percolation API:
        1. Percolation(n)初始化fopen``[n][n]``和UF对象，并设置up与最上层所有格子互连。
        2. open(r,c)每打开一个格子，修改fopen，同时判断其上下左右是否存在开发格子，若存在使用uf.union()将其连接。
        3. isOpen(r,c)：返回fopen
        4. isFull(r,c)：判断该格子是否与up互连
        5. percolate()判断底层是否有格子与up连接，若存在，即为渗透，注意n==1，
    4. PercolationStats则是调用Percolation进行n次独立实验，计算期望和方差。

4. 优化 
V1: percolation.java中存在行数n无初始化问题，解决方法：使用二维数组fopen[n][n],
用数组长度保存n。

V2: 当系统渗透后，底部非full的open格子也默认为full，原因是初始化时所有底部格子与down连接，当渗透后，up与down相连接，底部open的格子则为full。
解决方法：删除底部所有格子与down连接，检查渗透时，检查所有底部格子是否存在一个与up相连。

V3: 在isFull方法中进行连接操作再进行判断，在某一点上单独调用isFull方法可能判断失败，应该将连接操作放在open方法中，打开某个格子，即与上下左右进行连接。

v4: PercolationStats中stddev直接返回标准差s，而非方差s^2；且当n=1时，percolation.java中的percolates方法需要特殊判断，否则默认为渗透状态。

v5: PercolationStats中遍历次数trials直接调用时，存在无初始值问题（静态，默认为0），应该用x[]的长度表示。

5. 注意：
    1. 标准化API，模型的主要功能应该由模型中的方法完成，可以重复被调用，而不应该需要在Test方法如main中还需要进行进一步处理，所有的处理应该都在API中完成。
    2. API中声明的静态变量若需声明则一定要初始化，否则在调用API时静态变量无初始值，不推荐使用静态，而应该使用对象变量，由调用者赋值。