### ReservoirSampling:水塘抽样问题
1. 在高德纳的计算机程序设计艺术中，有如下问题：可否在一未知大小的集合中，随机取出一元素？例如在一很大，但未知行数的文字档中抽取任意一行。如果要确保每一行抽取的概率相等，即是说如果最后发现文字档共有N行，则每一行被抽取的概率均为1/N。
而水塘抽样问题就是在n个元素中随机取出k个数据，其中n为一很大或未知的数量，尤其适用于不能把所有n个项目都存放到主内存的情况。

2.  其解决方案是蓄水池抽样，思想是保持一个集合作为蓄水池，依次遍历集合中所有元素时，以一定概率取代蓄水池中的某一元素。


3. 先来看取出一个元素，这里假设n已知：
n=1：只有一个数据，直接取出，概率为1/1；
n=2：首先将第一个元素作为蓄水池，取第二个元素时，要想每个数的概率为0.5，可以随机生成一个0到1的数据p，当p小于0.5，用第二个数据替换第一个数据，否则不变；此时每个数据的取出概率都是0.5。
n=3：事先分析，为满足条件每个数的取出概率都是1/3，在取前两个数据时，可以按n=2处理，取第三个数据，仍按p小于1/3的概率表示是否进行替换，而前面两个数据留下来的概率也是(1-1/3)*1/2=1/3...

由上面的分析得出：
**在取第n个数据的时候，我们生成一个0到1的随机数p，如果p小于1/n，保留第n个数替换蓄水池。若大于1/n，继续保留前面的数。直到数据流结束，返回此数。**

下面用数学归纳法证明此结论。
1)当n=1时，第一个元素以1/1的概率返回，符合条件。
2)假设当n=k时成立，即每个元素都以1/k的概率返回，先证明n=k+1时，是否成立。
对于最后一个元素显然以1/k+1的概率返回，符合条件，对于前k个数据，被保留的概率为1/k * (1- 1/k+1)=1/k+1，满足题意。

4. 再分析取出k个数据，在题目一的分析上，可以直接将结论替换为：
**在取第n个数据的时候，我们生成一个0到1的随机数p，如果p小于k  /n，替换池中任意一个为第n个数。若大于k /n，继续保留前面的数。直到数据流结束，返回此k个数。但是为了保证计算机计算分数额准确性，一般是生成一个0到n的随机数，跟k相比，道理是一样的。**

验证：
1. 初始时将前面k<=n个数据取出作为蓄水池，再处理第k+1个数据。
2. 处理第k+1个数据时，有两种情况：保留第k+1个元素替换蓄水池中的某一个元素；不保留，蓄水池不变。
    1. 第k+1个元素留下的概率为k/k+1。
    2. 前面k个元素被保留的概率在两种情况讨论：
        (1) 保留第k+1元素，前k个元素的某一个不被选择：$$ \frac {k} {(k+1)} *(1-\frac{1}{k}) = \frac{k-1}{k+1}； $$
        (2) 不保留第k+1个元素：$$ \frac{1}{(k+1)} $$    两者相加即为$\frac{k}{(k+1)} $.说明新元素和旧元素留下的概率是相等的。

3. 处理第n个数据时，有两种情况：保留第n个元素，替换蓄水池中的某一个元素；不保留，蓄水池不变。
    1. 第n个元素留下的概率为k/n。
    2. 前面n-1个元素被保留的概率在两种情况讨论：
        (1) 选第n个，前n-1个元素某一个已被选入最后自身不被选中：$$ \frac{k}{n} * \frac{k}{n-1}*(1 - \frac{1}{k}) = \frac {k*(k-1)} {n*(n-1)} $$
        (2) 不选第n个，前n个元素某一个要保留的概率,$$
(1- \frac{k}{n})*\frac{k}{n-1} = \frac {k*(n-k)} {n*(n-1)} $$
两者相加即为k/n，说明概率是相等的。

### 伪代码如下：

    ```
    /**
     * @param stream:表示输入的未知数据流
     * @param reservior：表示蓄水池
     */
    public <Item> void reserviorsampling(Item[] stream,Item[] reservior, int k){
        
        //先取出k个放入蓄水池
        for(int i = 0; i < k; i++)
            reservior[i] = stream[i];
        
        for(int j = k; stream != null; j++){
            //随机生成[0,j]之间的数p
            int p = random(0, j);
            if(p < k)
                //若p小于k，则保留stream[j],并替换
                reservior[p] = stream[j];
        }
    }
    ```

### 注意：
1. 在取出第n个元素时成一个0到1的随机数p，如果p小于k/n，替换池中任意一个为第n个数。若替换成生成0到n的随机数与k比，一定要注意概率替换成整数后就由连续型变成离散型，此时保留第n个元素的概率为k/n，也就是说生成的随机数范围一定要有n个整数，p``<k``的取值范围里面一定要有k个整数，才能到达范围k/n。

2. 使用数组表示蓄水池时，一定要注意数组下标与取数序号的关系，序号n=下标+1，生成随机数范围是以序号为准，随机数范围要有n个，p``<k``能取到k个整数，如上代码中，j应该是取第j+1个整数，因此生成的随机数范围应该是``[0, j]``包括0到j共j+1个整数，j``<``k时可以取到0到k-1共k的整数，概率刚好。





