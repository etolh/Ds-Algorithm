### Programming Assignment 5: Kd-Tree 
二维平面单位方阵中有n个点，完成其中两个算法：
1. 范围搜索：求包含在指定长方形（坐标轴平行）中所有的点集合
2. 最近点查找：求离指定点最近的邻接点
使用Point2D和RectHV分别表示点和长方形。

#### Brute-force：PointSET 
1. 暴力求解：使用TreeSet表示RedBlackBST，使用TreeSet自带方法添加结点，迭代器遍历所有结点进行范围查找和最近点查找。

#### 2d-tree implementation
1. 使用2d-tree树进行范围查找和最小值查找，自定义2d树的节点使用二维点（或其坐标）作为key，对应的value是该结点子树的长方形（包含子树上所有结点）。

2. insert和draw：
    1. 向2d-tree插入结点时，需要注意二维点的判断方位：第一层以x坐标划分左右，第二层以y划分，依次交换和插入时需要动态构建所在点对应的rect。采用深度优先递归插入，传入参数为当前子树结点h、点p、h的前驱、当前层次layer；利用layer进行查找插入位置，当遍历到null时，根据前驱pre动态构建长方形rect，并返回插入的新结点。
    2. draw：深度递归遍历所有点，并根据当前层次决定分割线的颜色（水平、垂直），由点对应的rect确定线坐标。

3. 范围查找range(RectHV rect, Queue<Point2D> q, Node x) 从root开始查找，对于某一结点，判断是否在指定rect中，若在加入队列；
然后再递归地查找其左右子树，同时为减少时间，只有子树对应的rect与指定rect相交，才表示子树可能有结点在rect中，否则不查找。边界：找到null返回。

4. 最近点nearest1(Point2D p, Node x)：
设置成员变量保存最小距离和最近点，避免传入参数递归时变化；从root遍历起，对应某一点计算到p的距离，若小于最小值，则更新；再对左右子树递归遍历。同时为优化，一，对左右子树遍历时，首先对和p一方的子树进行遍历，通常最近点和p在一方的可能性更大。二，为减少递归次数，先对同一方子树遍历后，若p到另一方子树的距离（p与子树根结点对应的rect的距离）大于最小距离，则无需对另一方再进行遍历。

#### 优化
1. insert优化RectHV：
插入时传入参数使用前驱而不是rect，避免每递归一次都需要创建一个新的rect对象。
2. nearest递归优化、distanceSquaredTo优化：
对左右子树遍历，先遍历同侧子树，再进行判断。
3. RangeSearch优化时不判断指定rect与子树对应的rect相交，而是判断指定的rect与当前结点（子树的父节点）的分割线相交，若相交，递归遍历两个子树，否则只遍历rect同侧的子树。


#### 二叉树的深度遍历（递归） method(Node x, Key k)
1. 深度遍历二叉树，对于当前结点x，若为null则表示遍历到底，直接返回；若不为null，则对当前结点进行操作（主要部分），如打印、修改等，再根据当前结点x与k的关系，遍历x的左右子树。